---
title: "Missed Connections Analysis"
author: "Karla Fettich"
date: "March 15, 2019"
output: html_document
---

```{r setup}

# load all packages needed

rm(list = ls())
wd <- "/home/karla/Documents/RLadies/joys_fork/2019_datathon"

knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = wd)
library(rgdal)
library(stringr)
library(raster)
library(tmap)
library(hotspots)
library(geosphere)
library(dplyr)
library(tidyr)
library(sp)
library(rgeos)

```

In this analysis, I'm going to try and answer the question: what geographical factors contribute to the inefficient processing of an application? The fopllowing definitions will apply: 

1. denied applications: "denied", "do not follow up"
2. applications that adopted at PAWS: "adopted", "adoption follow up", "returned"
3. applications that adopted elsewhere: "adopted elsewhere"
4. approved applications: "approved", "ready to adopt", "ready for review", "reviewed with handouts only", "approved with limitation", "dog meet"
5. applications in limbo: "needs review before approval", "manager decision", "vet" , "need vet info", "need roommates vet info","not utd","questions", "not s n","need to see id", "need info", "checks", "needs app attached", "rescue check", "pet policy", "need written ll permission", "opa", "need proof of ownership", "landlord"
6. applications with limitation: "declaw only", "red flag", "unsure foster or adopt", "foster to adopt", "serial no show"

Basically, I'll go down this list for each application; if an application was "denied", all other labels will be ignored. If this application was not "denied", we check if it has the labels "adopted", "adoption follow-up" or "returned. If no such label is found, check if "adopted elsewhere". Proceed down this list. 

## Load datasets

### Shape files

First, I'll import the geo data for NJ and PA.

```{r import shape files}

# load geo data for nj & pa

nj <- shapefile("./Analyses/3_GIS/tl_2018_34_tract/tl_2018_34_tract.shp")
pa <- shapefile("./Analyses/3_GIS/tl_2018_42_tract/tl_2018_42_tract.shp")
pa_nj <- rbind(nj,pa)

# summary(pa_nj)
```


### Petpoint 

Then, I'll import PetPoint data. I am going to get rid of petpoint entries that don't have a GEOID, because these are animals that either got euthanized, or got adopted outside the area of interest (PA and NJ). 

```{r import petpoint data}

pp <- read.csv("./Data/petpoint.csv", stringsAsFactors = FALSE)
pp %>% 
  filter(is.na(INTPTLON)) %>%
  group_by(outcome_type) %>%
  summarise(n = n())
```

Everything except the "Adoption" line in this list is not informative for this analysis, so we can remove these. Let's take a closer look at the Adoptions to make sure we're not missing anything. 

```{r closer look at adoptions line}
pp %>% 
  filter(is.na(INTPTLON), outcome_type=="Adoption") %>%
  group_by(outcome_state) %>%
  summarise(n = n())
```

All these adoptions are from states other than NJ and PA; also, the numbers are fairly low (except DE and NY, which are also low in comparison). So we can remove all these entries from analysis.

```{r keep clean pp dataset}
pp <- pp[which(!is.na(pp$INTPTLON)),]
which(duplicated(pp))
```

### Applications data

I'll now load the applications data for both cats and dogs. We'll also look at these datasets the same way as for petpoint - getting rid of applications that don't have GEOIDs and assessing why those might be missing.

```{r import dog applications data}

dogs <- read.csv("./Data/dog_apps.csv", stringsAsFactors = FALSE)
dogs %>% 
  filter(is.na(INTPTLON)) %>%
  group_by(State) %>%
  summarise(n = n())
dogs <- dogs[!is.na(dogs$INTPTLON),]  # get rid of geo NAs
which(duplicated(dogs))
```

We have 2 PA applicants that have missing geo data. Since it's a low number, I will leave this as missing (can't re-do the GEO matching so we'll just have to run it as is). Everyone else is from states outside PA and NJ. 

```{r import cat applications data}
cats <- read.csv("./Data/cat_apps.csv", stringsAsFactors = FALSE)
cats %>% 
  filter(is.na(INTPTLON)) %>%
  group_by(State) %>%
  summarise(n = n())
cats <- cats[!is.na(cats$INTPTLON),]  # get rid of geo NAs
which(duplicated(cats))
```
For cats, we have 7 PA applicants with missing geo info. Ok. 

```{r cards}
dog.cards <- read.csv("./Data/dog_cards.csv", stringsAsFactors = FALSE)
dog.appsandcards <- merge(dogs, dog.cards, by.x="outcome_trello_id", by.y="id")
# check for duplicates
which(duplicated(dog.appsandcards$outcome_trello_id))
# because we'r enot sure how to handle duplicates, we'll remove all the ids that appear multiple times
dog.appsandcards <- dog.appsandcards[which(!dog.appsandcards$outcome_trello_id %in% dog.appsandcards$outcome_trello_id[which(duplicated(dog.appsandcards$outcome_trello_id))]),]

cat.cards <- read.csv("./Data/cat_cards.csv", stringsAsFactors = FALSE)
cat.appsandcards <- merge(cats, cat.cards, by.x="outcome_trello_id", by.y="id")
# check for duplicates
which(duplicated(cat.appsandcards$outcome_trello_id))
# because we'r enot sure how to handle duplicates, we'll remove all the ids that appear multiple times
cat.appsandcards <- cat.appsandcards[which(!cat.appsandcards$outcome_trello_id %in% cat.appsandcards$outcome_trello_id[which(duplicated(cat.appsandcards$outcome_trello_id))]),]

```


```{r correct time formats and calculate time from application to adoption}
# 
# dogs.pa_nj <- merge(dogs, pp, by="outcome_trello_id",all=TRUE)
# dogs.pa_nj <- dogs.pa_nj[dogs.pa_nj$species=="Dog",]
# dogs.pa_nj$outcome_date <- as.POSIXlt(dogs.pa_nj$outcome_date, format="%m/%d/%Y %H:%M %p")
# dogs.pa_nj$date_submitted <- as.POSIXlt(dogs.pa_nj$date_submitted, format="%m/%d/%Y")
# dogs.pa_nj$time_to_adoption <- as.numeric(difftime(dogs.pa_nj$outcome_date,
#                                         dogs.pa_nj$date_submitted,
#                                         units="days"))
# 
# cats.pa_nj <- merge(cats, pp, by="outcome_trello_id",all=TRUE)
# cats.pa_nj <- cats.pa_nj[dogs.pa_nj$species=="Cat",]
# cats.pa_nj$outcome_date <- as.POSIXlt(cats.pa_nj$outcome_date, format="%m/%d/%Y %H:%M %p")
# cats.pa_nj$date_submitted <- as.POSIXlt(cats.pa_nj$date_submitted, format="%m/%d/%Y")
# cats.pa_nj$time_to_adoption <- as.numeric(difftime(cats.pa_nj$outcome_date,
#                                         cats.pa_nj$date_submitted,
#                                         units="days"))
```

### Census data

```{r}
educ <- read.csv("/home/karla/Documents/RLadies/joys_fork/2019_datathon/Analyses/3_GIS/PA_Education/ACS_17_5YR_S1401_with_ann.csv",
                 stringsAsFactors = FALSE)   # enrollment in college or grad school
educ <- educ[,c("GEO.id2",
                "HC02_EST_VC11",  # percent population enrolled in college or grad school
                "HC02_EST_VC08")]          # percent population enrolled in college 
colnames(educ) <- c("GEO.id2", "edu.collorgrad","edu.coll")


rent <- read.csv("/home/karla/Documents/RLadies/joys_fork/2019_datathon/Analyses/3_GIS/PA_Census/ACS_17_5YR_B25058_with_ann.csv",
                 stringsAsFactors = FALSE)   # median contract rent
rent <- rent[,c("GEO.id2",
                "HD01_VD01")] # estimate, median contract rent 
colnames(rent) <- c("GEO.id2", "rent.median")

comp <- read.csv("/home/karla/Documents/RLadies/joys_fork/2019_datathon/Analyses/3_GIS/PA_Census/ACS_17_5YR_B28010_with_ann.csv",
                 stringsAsFactors = FALSE)   # computing devices
comp <- comp[,c("GEO.id2",
                "HD01_VD01",   # estimate total (assumed total population?)
                "HD01_VD02")] # estimate has one or more types of computing devices
colnames(comp) <- c("GEO.id2", "comp.total", "comp.oneormore")

net <- read.csv("/home/karla/Documents/RLadies/joys_fork/2019_datathon/Analyses/3_GIS/PA_Census/ACS_17_5YR_B28011_with_ann.csv",
                 stringsAsFactors = FALSE)   # internet subscription
net <- net[,c("GEO.id2",
                "HD01_VD01",   # estimate total (assumed total population?)
                "HD01_VD02")] # estimate total with an internet subscription
colnames(net) <- c("GEO.id2", "net.total", "net.subscr")

transit <- read.csv("/home/karla/Documents/RLadies/joys_fork/2019_datathon/Analyses/3_GIS/PA_Census/ACS_17_5YR_S0801_with_ann.csv",
                 stringsAsFactors = FALSE)   # internet subscription
transit <- transit[,c("GEO.id2",
                "HC01_EST_VC01",   # Total; Estimate; Workers 16 years and over
                "HC01_EST_VC03",  # Total; Estimate; MEANS OF TRANSPORTATION TO WORK - Car, truck, or van
                "HC01_EST_VC10", # Total; Estimate; MEANS OF TRANSPORTATION TO WORK - Public transportation (excluding taxicab)
                "HC01_EST_VC11", # Total; Estimate; MEANS OF TRANSPORTATION TO WORK - Walked
                "HC01_EST_VC12", # Total; Estimate; MEANS OF TRANSPORTATION TO WORK - Bicycle
                "HC01_EST_VC13", # Total; Estimate; MEANS OF TRANSPORTATION TO WORK - Taxicab, motorcycle, or other means
                "HC01_EST_VC14", # Total; Estimate; MEANS OF TRANSPORTATION TO WORK - Worked at home
                "HC01_EST_VC55", # Total; Estimate; TRAVEL TIME TO WORK - Mean travel time to work (minutes)
                "HC01_EST_VC58", # Total; Estimate; VEHICLES AVAILABLE - Workers 16 years and over in households
                "HC01_EST_VC59")] # Total; Estimate; VEHICLES AVAILABLE - Workers 16 years and over in households - No vehicle available 
colnames(transit) <- c("GEO.id2", "transit.total", "transit.vehicle", "transit.public", "transit.walk","transit.bike","transit.taxi","transit.home",
                   "transit.traveltime","transit.vehicles.total","transit.vehicles.none")

census <- merge(educ, rent, by="GEO.id2", all=TRUE)
census <- merge(census, comp, by="GEO.id2", all=TRUE)
census <- merge(census, net, by="GEO.id2", all=TRUE)
census <- merge(census, transit, by="GEO.id2", all=TRUE)
census <- mutate_all(census, function(x) as.numeric(as.character(x)))
census$comp.oneormore <- (census$comp.oneormore/census$comp.total)*100
census$net.subscr <- (census$net.subscr/census$net.total)*100
census$transit.vehicles <- 100-(census$transit.vehicles.none/census$transit.vehicles.total)*100
census$collgrad50 <- ifelse(census$edu.collorgrad > quantile(census$edu.collorgrad,.5, na.rm=TRUE),1,0)

```

Analyses Dogs

```{r}

dog.appsandcards$status <- NA
dog.appsandcards$status[which(grepl(paste(c("declaw only", 
                                            "red flag", 
                                            "unsure foster or adopt", 
                                            "foster to adopt", 
                                            "serial no show"), collapse="|"), dog.appsandcards$label_names))] <- 6
dog.appsandcards$status[which(grepl(paste(c("needs review before approval", 
                                            "manager decision", 
                                            "vet" , 
                                            "need vet info", 
                                            "need roommates vet info",
                                            "not utd",
                                            "questions", 
                                            "not s n",
                                            "need to see id", 
                                            "need info", 
                                            "checks", 
                                            "needs app attached", 
                                            "rescue check", 
                                            "pet policy", 
                                            "need written ll permission", 
                                            "opa", 
                                            "need proof of ownership", 
                                            "landlord"), collapse="|"), dog.appsandcards$label_names))] <- 5
dog.appsandcards$status[which(grepl(paste(c("approved", 
                                            "ready to adopt", 
                                            "ready for review", 
                                            "reviewed with handouts only", 
                                            "approved with limitation", 
                                            "dog meet"), collapse="|"), dog.appsandcards$label_names))] <- 4
dog.appsandcards$status[which(grepl(paste(c("adopted elsewhere"), collapse="|"), dog.appsandcards$label_names))] <- 3
dog.appsandcards$status[which(grepl(paste(c("adopted", 
                                            "adoption follow up", 
                                            "returned"), collapse="|"), dog.appsandcards$label_names))] <- 2
dog.appsandcards$status[which(grepl(paste(c("denied", "do not follow up"), collapse="|"), dog.appsandcards$label_names))] <- 1
dog.appsandcards$status[is.na(dog.appsandcards$status)] <- 5

dog.appsandcards %>% 
  group_by(status) %>%
  summarise(n=n())

dogs.geo <- dog.appsandcards[,c("GEOID","status","outcome_trello_id","label_names")] %>% 
  group_by(GEOID, status) %>%
  summarise(apps=n()) %>%
  spread(status, apps)

dogs.geo <- merge(dogs.geo, census, by.x="GEOID", by.y="GEO.id2")
dogs.geo[is.na(dogs.geo)] <- 0

dogs.geo.spatial <-
  sp::merge(x = pa_nj, y = dogs.geo, by = "GEOID")
dogs.geo.spatial <- dogs.geo.spatial[dogs.geo.spatial$COUNTYFP=="101",]

# normalize everything

dogs.geo.spatial$z2 <- scale(dogs.geo.spatial$`2`)
dogs.geo.spatial$zedu.collorgrad <- scale(dogs.geo.spatial$edu.collorgrad)
dogs.geo.spatial$zrent.median <- scale(dogs.geo.spatial$rent.median)
dogs.geo.spatial$ztransit.traveltime <- scale(dogs.geo.spatial$transit.traveltime)
dogs.geo.spatial$ztransit.vehicles <- scale(dogs.geo.spatial$transit.vehicles)

model <- lm(dogs.geo.spatial$z2 ~ dogs.geo.spatial$zedu.collorgrad + 
              dogs.geo.spatial$zrent.median + 
              dogs.geo.spatial$ztransit.traveltime + 
              dogs.geo.spatial$ztransit.vehicles)
summary(model)
plot(model)

resids<-residuals(model)
dogs.geo.spatial$map.resids <- resids
qtm(dogs.geo.spatial, fill = "map.resids")

library("spgwr")
GWRbandwidth <- gwr.sel(z2 ~ zedu.collorgrad + zrent.median + ztransit.traveltime + ztransit.vehicles, data=dogs.geo.spatial,adapt=T)

gwr.model = gwr(z2 ~ zedu.collorgrad + zrent.median + ztransit.traveltime + ztransit.vehicles, data=dogs.geo.spatial, 
                adapt=GWRbandwidth, hatmatrix=TRUE, se.fit=TRUE) 

gwr.model

results <-as.data.frame(gwr.model$SDF)
names(results)

gwr.map <- cbind(dogs.geo.spatial, as.matrix(results))
qtm(gwr.map, fill = "localR2")

map1 <- tm_shape(gwr.map) + tm_fill("edu.collorgrad", n = 5, style = "quantile")  + tm_layout(frame = FALSE, legend.text.size = 0.5, legend.title.size = 0.6)
map2 <- tm_shape(gwr.map) + tm_fill("zedu.collorgrad.1", n = 5, style = "quantile", title = "Enrolled Coefficient") + tm_layout(frame = FALSE, legend.text.size = 0.5, legend.title.size = 0.6)
map3 <- tm_shape(gwr.map) + tm_fill("rent.median", n = 5, style = "quantile") + tm_layout(frame = FALSE, legend.text.size = 0.5, legend.title.size = 0.6)
map4 <- tm_shape(gwr.map) + tm_fill("zrent.median.1", n = 5, style = "quantile", title = "Rent Coefficient") + tm_layout(frame = FALSE, legend.text.size = 0.5, legend.title.size = 0.6)

map5 <- tm_shape(gwr.map) + tm_fill("transit.traveltime", n = 5, style = "quantile") + tm_layout(frame = FALSE, legend.text.size = 0.5, legend.title.size = 0.6)
map6 <- tm_shape(gwr.map) + tm_fill("ztransit.traveltime.1", n = 5, style = "quantile", title = "Traveltime Coefficient") + tm_layout(frame = FALSE, legend.text.size = 0.5, legend.title.size = 0.6)

map7 <- tm_shape(gwr.map) + tm_fill("transit.vehicles", n = 5, style = "quantile") + tm_layout(frame = FALSE, legend.text.size = 0.5, legend.title.size = 0.6)
map8 <- tm_shape(gwr.map) + tm_fill("ztransit.vehicles.1", n = 5, style = "quantile", title = "Vehicles Coefficient") + tm_layout(frame = FALSE, legend.text.size = 0.5, legend.title.size = 0.6)

```





library(vcdExtra)
library(MASS)
library(pscl)
library(boot)
library(stats)
library(mpath)

poisson.test(x = sum(dogs.geo$`2`), T=length(dogs.geo$`2`))
zero.test(dogs.geo$`2`)

z2 <- zeroinfl(`2` ~ edu.collorgrad + 
               rent.median + 
               transit.traveltime, data=dogs.geo, dist="poisson")
summary(z2)
be.zeroinfl(z2, data=dogs.geo,dist="poisson")


poisson.test(x = sum(dogs.geo$`4`), T=length(dogs.geo$`4`))
zero.test(dogs.geo$`4`)

z4 <- zeroinfl(`4` ~ edu.collorgrad, data=dogs.geo, dist = "poisson")

poisson.test(x = sum(dogs.geo$`5`), T=length(dogs.geo$`4`))
zero.test(dogs.geo$`5`)

z5 <- zeroinfl(`5` ~ edu.collorgrad, data=dogs.geo)

detach(package:vcdExtra)
detach(package:MASS)
detach(package:pscl)
detach(package:boot)
detach(package:stats)

## Exponentiated coefficients
# expCoef <- exp(coef((z2)))
# expCoef <- matrix(expCoef, ncol = 2)
# rownames(expCoef) <- c("intercept",
#                       "edu.collorgrad",
#                        "rent.median",
#                        "net.subscr",
#                        "transit.traveltime",
#                        "transit.vehicles")
# colnames(expCoef) <- c("Count_model","Zero_inflation_model")
# expCoef


dogs.spatial <-
  sp::merge(x = pa_nj, y = dogs.geo, by = "GEOID")
# dogs.spatial.2 <- dogs.spatial.2[which(!is.na(dogs.spatial.2$apps)), ]
# dogs.spatial.hotspot <- dogs.spatial.2[which(dogs.spatial.2$apps > hotspots(dogs.spatial.2$apps)$positive.cut),]

tmap_mode("view")
tm_basemap("OpenStreetMap.BlackAndWhite") +
  tm_shape(dogs.spatial.hotspot) + 
  tm_fill("apps", palette = "Reds", alpha=0.85)


```

Analyses Cats

```{r}

cat.appsandcards$status <- NA
cat.appsandcards$status[which(grepl(paste(c("declaw only", 
                                            "red flag", 
                                            "unsure foster or adopt", 
                                            "foster to adopt", 
                                            "serial no show"), collapse="|"), cat.appsandcards$label_names))] <- 6
cat.appsandcards$status[which(grepl(paste(c("needs review before approval", 
                                            "manager decision", 
                                            "vet" , 
                                            "need vet info", 
                                            "need roommates vet info",
                                            "not utd",
                                            "questions", 
                                            "not s n",
                                            "need to see id", 
                                            "need info", 
                                            "checks", 
                                            "needs app attached", 
                                            "rescue check", 
                                            "pet policy", 
                                            "need written ll permission", 
                                            "opa", 
                                            "need proof of ownership", 
                                            "landlord"), collapse="|"), cat.appsandcards$label_names))] <- 5
cat.appsandcards$status[which(grepl(paste(c("approved", 
                                            "ready to adopt", 
                                            "ready for review", 
                                            "reviewed with handouts only", 
                                            "approved with limitation", 
                                            "dog meet"), collapse="|"), cat.appsandcards$label_names))] <- 4
cat.appsandcards$status[which(grepl(paste(c("adopted elsewhere"), collapse="|"), cat.appsandcards$label_names))] <- 3
cat.appsandcards$status[which(grepl(paste(c("adopted", 
                                            "adoption follow up", 
                                            "returned"), collapse="|"), cat.appsandcards$label_names))] <- 2
cat.appsandcards$status[which(grepl(paste(c("denied", "do not follow up"), collapse="|"), cat.appsandcards$label_names))] <- 1
cat.appsandcards$status[is.na(cat.appsandcards$status)] <- 5

cats.geo <- cat.appsandcards[,c("GEOID","status","outcome_trello_id","label_names")] %>% 
  group_by(GEOID, status) %>%
  summarise(apps=n()) %>%
  spread(status, apps)

cats.geo <- merge(cats.geo, census, by.x="GEOID", by.y="GEO.id2")
cats.geo[is.na(cats.geo)] <- 0

library(vcdExtra)
library(MASS)
library(pscl)
library(boot)
library(stats)

poisson.test(x = sum(cats.geo$`2`), T=length(cats.geo$`2`))
zero.test(cats.geo$`2`)

z2 <- zeroinfl(`2` ~ edu.collorgrad, data=cats.geo, dist = "poisson")
summary(z2)

poisson.test(x = sum(cats.geo$`4`), T=length(cats.geo$`4`))
zero.test(cats.geo$`4`)

z4 <- glm.nb(`4` ~ edu.collorgrad, data=cats.geo)

poisson.test(x = sum(cats.geo$`5`), T=length(cats.geo$`4`))
zero.test(cats.geo$`5`)

z5 <- zeroinfl(`5` ~ edu.collorgrad, data=cats.geo)

detach(package:vcdExtra)
detach(package:MASS)
detach(package:pscl)
detach(package:boot)
detach(package:stats)
```


Let's read in some education data



```{r}
cats.geo <- cat.appsandcards[,c("GEOID","outcome_trello_id")] %>% 
  group_by(GEOID) %>%
  summarise(apps=n())


pp.geo.cat <- pp[which(pp$outcome_date > "2018-08-31" & pp$species == "Cat") ,c("GEOID","species")] %>% 
  group_by(GEOID) %>%
  summarise(adoptions=n())

pp.dogs.geo <- merge(pp.geo.dog, dogs.geo, by="GEOID", all=TRUE)
pp.cats.geo <- merge(pp.geo.cat, cats.geo, by="GEOID", all=TRUE)

```

Let's see whether the different application statuses have different geographical distributions

```{r}
pp.dogs.geo.1 <- pp.dogs.geo %>%
  

```


```{r}

pp$outcome_date <- as.POSIXlt(pp$outcome_date, format="%m/%d/%Y %H:%M %p")
pp.geo.dog <- pp[which(pp$outcome_date > "2018-08-31" & pp$species == "Dog") ,c("GEOID","species")] %>% 
  group_by(GEOID) %>%
  summarise(adoptions=n())


pp.dogs.geo$adoptions[is.na(pp.dogs.geo$adoptions)] <- 0
pp.dogs.geo$apps[is.na(pp.dogs.geo$apps)] <- 0
pp.dogs.geo$diff <- pp.dogs.geo$apps - pp.dogs.geo$adoptions

pp.cats.geo$adoptions[is.na(pp.cats.geo$adoptions)] <- 0
pp.cats.geo$apps[is.na(pp.cats.geo$apps)] <- 0
pp.cats.geo$diff <- pp.cats.geo$apps - pp.cats.geo$adoptions




pp.cats.spatial <-
  sp::merge(x = pa_nj, y = pp.cats.geo, by = "GEOID")
pp.cats.spatial <- pp.cats.spatial[which(!is.na(pp.cats.spatial$diff)), ]
pp.cats.spatial.hotspot <- pp.cats.spatial[which(pp.cats.spatial$diff > hotspots(pp.cats.spatial$diff)$positive.cut),]

tmap_mode("view")
tm_basemap("OpenStreetMap.BlackAndWhite") +
  tm_shape(pp.cats.spatial.hotspot) + 
  tm_fill("diff", palette = "Reds", alpha=0.85)
```

Let's calculate distance from each point to adoption locations. 

```{r}
# PAWS Adoption locations taken from their website, and latlong obtained via https://gps-coordinates.org/
# PAC lat = 39.952030; Long = -75.143410 
# NE lat =  40.084923, long = -75.036904
# Kawaii kitty Cafe Lat = 39.93867, long = -75.1496
# Petsmart Oregon Ave Lat = 39.917239, Lon = -75.187238
# Petsmart Broad & Washington Lat = 39.937967, Lon = -75.167576
# Grays Ferry Lat = 39.938748 Lon = -75.192532

for (i in 1:nrow(pp.cats.spatial)){
  pp.cats.spatial$PAC.dist[i] <-  distm(c(as.numeric(pp.cats.spatial$INTPTLON[i]),as.numeric(pp.cats.spatial$INTPTLAT[i])),c(-75.143410, 39.952030), fun=distGeo)
  pp.cats.spatial$NE.dist[i] <-  distm(c(as.numeric(pp.cats.spatial$INTPTLON[i]),as.numeric(pp.cats.spatial$INTPTLAT[i])),c(-75.036904, 40.084923), fun=distGeo)
  pp.cats.spatial$KK.dist[i] <-  distm(c(as.numeric(pp.cats.spatial$INTPTLON[i]),as.numeric(pp.cats.spatial$INTPTLAT[i])),c(-75.1496, 39.93867), fun=distGeo)
  pp.cats.spatial$PS.dist[i] <-  distm(c(as.numeric(pp.cats.spatial$INTPTLON[i]),as.numeric(pp.cats.spatial$INTPTLAT[i])),c(-75.187238, 39.917239), fun=distGeo)
  pp.cats.spatial$PSO.dist[i] <-  distm(c(as.numeric(pp.cats.spatial$INTPTLON[i]),as.numeric(pp.cats.spatial$INTPTLAT[i])),c(-75.187238, 39.917239), fun=distGeo)
  pp.cats.spatial$PSO.dist[i] <-  distm(c(as.numeric(pp.cats.spatial$INTPTLON[i]),as.numeric(pp.cats.spatial$INTPTLAT[i])),c(-75.167576, 39.937967), fun=distGeo)
  pp.cats.spatial$GF.dist[i] <-  distm(c(as.numeric(pp.cats.spatial$INTPTLON[i]),as.numeric(pp.cats.spatial$INTPTLAT[i])),c(-75.192532, 39.938748), fun=distGeo)
  pp.cats.spatial$shortest.distance[i] <- min(pp.cats.spatial$PAC.dist[i],
                                              pp.cats.spatial$NE.dist[i],
                                              pp.cats.spatial$KK.dist[i],
                                              pp.cats.spatial$PS.dist[i],
                                              pp.cats.spatial$PSO.dist[i],
                                              pp.cats.spatial$GF.dist[i])
  }
cor.test(pp.cats.spatial$diff, pp.cats.spatial$shortest.distance)
cor.test(pp.cats.spatial$adoptions, pp.cats.spatial$shortest.distance)
cor.test(pp.cats.spatial$apps, pp.cats.spatial$shortest.distance)

for (i in 1:nrow(pp.dogs.spatial)){
  pp.dogs.spatial$PAC.dist[i] <-  distm(c(as.numeric(pp.dogs.spatial$INTPTLON[i]),as.numeric(pp.dogs.spatial$INTPTLAT[i])),c(-75.143410, 39.952030), fun=distGeo)
  pp.dogs.spatial$NE.dist[i] <-  distm(c(as.numeric(pp.dogs.spatial$INTPTLON[i]),as.numeric(pp.dogs.spatial$INTPTLAT[i])),c(-75.036904, 40.084923), fun=distGeo)
  pp.dogs.spatial$KK.dist[i] <-  distm(c(as.numeric(pp.dogs.spatial$INTPTLON[i]),as.numeric(pp.dogs.spatial$INTPTLAT[i])),c(-75.1496, 39.93867), fun=distGeo)
  pp.dogs.spatial$PS.dist[i] <-  distm(c(as.numeric(pp.dogs.spatial$INTPTLON[i]),as.numeric(pp.dogs.spatial$INTPTLAT[i])),c(-75.187238, 39.917239), fun=distGeo)
  pp.dogs.spatial$PSO.dist[i] <-  distm(c(as.numeric(pp.dogs.spatial$INTPTLON[i]),as.numeric(pp.dogs.spatial$INTPTLAT[i])),c(-75.187238, 39.917239), fun=distGeo)
  pp.dogs.spatial$PSO.dist[i] <-  distm(c(as.numeric(pp.dogs.spatial$INTPTLON[i]),as.numeric(pp.dogs.spatial$INTPTLAT[i])),c(-75.167576, 39.937967), fun=distGeo)
  pp.dogs.spatial$GF.dist[i] <-  distm(c(as.numeric(pp.dogs.spatial$INTPTLON[i]),as.numeric(pp.dogs.spatial$INTPTLAT[i])),c(-75.192532, 39.938748), fun=distGeo)
  pp.dogs.spatial$shortest.distance[i] <- min(pp.dogs.spatial$PAC.dist[i],
                                              pp.dogs.spatial$NE.dist[i],
                                              pp.dogs.spatial$KK.dist[i],
                                              pp.dogs.spatial$PS.dist[i],
                                              pp.dogs.spatial$PSO.dist[i],
                                              pp.dogs.spatial$GF.dist[i])
  }
cor.test(pp.dogs.spatial$diff, pp.dogs.spatial$shortest.distance)
cor.test(pp.dogs.spatial$adoptions, pp.dogs.spatial$shortest.distance)
cor.test(pp.dogs.spatial$apps, pp.dogs.spatial$shortest.distance)

```